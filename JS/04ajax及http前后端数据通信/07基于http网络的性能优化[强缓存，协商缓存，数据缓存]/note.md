第一步：url解析

传输协议：基于它实现客户端和服务器端的数据通信【快递小哥】

    http: 超文本传输协议（除了传输文本外，还可以传输音视频，图片等富文本资源）
    
    https:经过SSL加密处理的HTTP,所以更安全【设计支付类的网站都是使用https】
    
    ftp 一般用于把本地的文件上传到服务器

域名：本身没有什么意义，就是一个好记的名字。

端口号：用来区分相同服务器上不同的项目（或者不同服务）的

    取值范围：0~65535之间
    
    + 80  HTTP
    
    + 443  HTTPS
    
    + 21  FTP

浏览器地址栏中输入的URL地址，如果我们自己不写端口号，浏览器会根据传输协议，帮助我们自动把端口号加上

查询字符串【俗称：问号参数】

    客户端基于“问号参数”可以把信息传递给服务器【GET系列请求经常这样干】
    
    客户端两个页面之间（或者两个组件之间）也可以基于“问号传参”实现信息传输【例如：列表到详情】

哈希值（HASH值）【俗称：#XXX】

    锚点定位
    
    基于HASH值实现哈希路由

如果URL地址中出现了中文以及某些特殊符号，为了防止传输过程中乱码，则需要进行加密（对称加密）/解密

   对整个URL加密：encodeURI/decodeURI 会对空格以及中文字符进行加密

   对URL查询字符串中传递的值进行单独加密：encodeURIComponent/decodeURIComponent在encodeURI的基础上，还可以对“://?#@”等特殊符号进行加密，所以不用其处理整个URL,只是处理传递参数的一部分值而已

```javascript
encodeURI("%") ----> 变成"25%"
encodeURI('http://www.baidu.com/huge student/胡歌.html')
-----> 变成
'http://www.baidu.com/huge%20student/%E8%83%A1%E6%AD%8C.html'
decodeURI()

`https://www.baidu.com/name=${encodeURIComponent('胡歌')}&from=${encodeURIComponent('http://www.qq.com/')}`
----->变成
https://www.baidu.com/name=%E8%83%A1%E6%AD%8C&from=http%3A%2F%2Fwww.qq.com%2F
```

    客户端 escape unescape 加密解密 不常用

/*****************************************************************************************************/

第二步： 缓存检查

 如果设定了缓存机制，则从服务器获取的信息会存储在：

+ 物理内存（硬盘）：Disk Cache
+ 虚拟内存（内存条）：Memory Cache

物理内存可以持久存储，但是虚拟内存在页面关闭后，存储的信息就都释放掉了

+ F5刷新：先找Memory Cache，没有再找Disk Cache
+ 页面关闭再打开：直接找Disk Cache
+ 强制刷新（CTRL+F5）：不找任务缓存，直接从服务器获取最新的

---



1,强缓存：只要本地缓存生效（有且未过期）则使用本地缓存的信息，不会向服务器发送请求；本地缓存失效才会从服务器重新获取最新的内容。

    + 强缓存由服务器设置，客户端浏览器去执行，无需前端写啥代码
    
    + 服务器再返回给客户端信息的时候，在“响应头”中携带Cache-Control（或者Expires）字段；客户端浏览器拿到这个字段后，则按照规则去缓存获取的信息及标识。
    
    + 每当客户端发送请求的时候，都去看一下缓存是否生效；生效则直接获取缓存数据，不生效再从服务器获取...

Expires 是Http/1.0版本使用的，存储的是具体的过期时间。

Cache-Control是HTTP/1.1版本使用的，可以基于max-age=259000指定过期时间，单位是秒。

两者都有则以最高支持的版本为主。

无论是从服务器获取的，还是从缓存中读取的，HTTP状态码都是以200为主

**** HTML页面**【绝对不能】**设置强缓存，否则无法保证服务器资源更新，客户端可以随时获取最新的信息。

---



2，协商缓存：每一次请求，都需要和服务器进行协商【看服务器资源是否更新，如果有更新，则直接获取最新的，如果没有更新，则获取缓存】

服务器资源只要更新：

    + 都会产生一个新的Etag标识值 例如：W/"5e8c1c8a-23239"
    
    + 服务器资源最后更新时间，存储到Last-Modified中 例如：Thu, 02 Jun 2022 02:13:32 GMT

每一次都向服务器发送请求，在请求头中携带If-None-Match[存储的是Etag的值]（或者If-Modified-Since[存储的是Last-Modified值]）给服务器；服务器接收到请求，会拿传递过来的值和服务器上资源最后更新的标识和时间做对比：

    + 一样：说明服务器资源距离上次缓存期间并没有更新过，此时服务器只需要返回304状态码即可（没有返回资源信息）；客户端接收到服务器的反馈结果，发现是304，则从缓存信息中获取内容渲染。
    
    + 不一样：说明资源更新了，则服务器返回最新的资源信息以及相关的标识【Etag或者Last-Modified】;客户端会把最新的信息以及标识重新缓存在本地。

每一次请求都需要问服务器是否更新，所以可以保证随时获取最新的信息；但是不如强缓存效率高。

/============================================================/

真实项目中，我们一般是：

+ HTML制作协商缓存
+ 其余资源即做强缓存也做协商缓存，这样在强缓存失效后，还可以基于协商缓存二次进行处理。

两种缓存都是“服务器设置”，客户端浏览器自动执行，无需前端编写代码；而且都是对静态资源文件的缓存处理。

---



3，数据缓存：把不需要经常更新的数据接口，做缓存处理

需求：本地有缓存数据且未过期，则从本地获取；本地缓存失效，则重新从服务器获取【类似于强缓存】

/***********/

需要前端基于JS存储方案以及相关的操作去编码实现。





---






http与https参考地址：https://www.cnblogs.com/wqhwe/p/5407468.html
