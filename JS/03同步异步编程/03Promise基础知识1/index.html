<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promise基础知识1</title>
</head>
<body>
  <script>
    /************************************************
     * 基于回调函数的方式封装ajax请求
     * ajax串行：多个ajax请求间存在依赖，只有上一个请求成功，才能发送下一个请求
     *          （例如:第二个请求的发送需要依赖第一个请求的结果）
     * ajx并行：请求之间没有啥依赖，可以同时发送多个请求【一般会额外处理一些事情:等待所有请求都成功，统一干啥事】
     * 
     * 在没有promise之前，基于回调函数的方式管理ajax请求，在串行的需求中，很容易产生“回调地域”。
     * 
     * ---------------------------------------------------
     * Promise是ES6中专门用来管理异步编程的，基于它可以避免回调地域的问题
     * 
     * **********************************************/ 

     const http1 = () => {
      return new Promise(resolve => {
        $.ajax({
          url: '/api/test1',
          success: resolve,
        })
      })
     }

     const http2 = () => {
      return new Promise(resolve => {
        $.ajax({
          url: '/api/test2',
          success: resolve,
        })
      })
     }

     const http3 = () => {
      return new Promise(resolve => {
        $.ajax({
          url: '/api/test3',
          success: resolve,
        })
      })
     }

     http1()
          .then(value => {
            console.log('第一个请求结果：',value);
            return http2()
          })
          .then(value => {
            console.log('第二个请求结果：',value);
            return http3();
          })
          .then(value => {
            console.log('第三个请求结果：',value);
          })

   //Promise 语法糖的写法
   (async function(){
    let value = await http1();
    console.log('第一个请求结果：',value);

    value = await http2();
    console.log('第二个请求结果：',value);

    value = await http3();
    console.log('第三个请求结果：',value);
   })();

  /********************************************************************************
   * Promise语法
   * Promise是ES6新增的内置类：
   *   + 不兼容IE浏览器【EDGE可以兼容的】：真实项目开发的时候，如果使用了promise，还要兼容IE浏览器，需要处理兼容
   *     1,bable/preset语法包，无法编译Promise内置类，它只能编译类似于let/const这种常规语法。
   *     2，我们需要基于@babel/polyfill实现promise的兼容处理【原理：基于ES5手动实现一个Promise】
   *   + 使用的时候是创建类的实例:实例具备私有属性，可以使用Promise.prototype上的方法,Promise作为对象存在一些静态的私有属性方法
   * 
   * ------------------------------------------------------------
   * 
   * let p1 = new Promise([executor])
   *     [executor]
   *     + 必须是一个函数，传递的不是函数则会报错：Uncaught TypeError: Promise resolver xxx is not a function
   *     + [executor]函数执行的时候，会接受两个实参值，我们分别用resolve/reject形参来存储
   * 
   * 实例p1具备的私有属性
   *    [[PromiseState]]:'pending' 实例状态：pending(准备/默认状态) & fulfilled(成功态)&rejected(失败态)
   *    [[PromiseResult]]: undefined 实例的值（结果）：存储成功的结果或者失败的原因，状态为pending则默认值是undefined
   * 
   * Promise.prototype 为实例提供的公共属性方法
   *     + then
   *     + catch
   *     + finally
   *     + Symbol(Symbol.toStringTag): 'Promise'
   * 
   * Promise 作为普通对象，具备静态私有属性方法
   *      + all
   *      + allSelected
   *      + any
   *      + race
   *      + reject
   *      + resolve
   *      + ...
   * ****************************************************************************/
  </script>
</body>
</html>