<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>闭包</title>
</head>
<body>
  <script>
    /************************************************************************
     * 浏览器垃圾回收机制【】
     *  1,标记清楚
     *  2,引用计数
     * 全局上下文：打开页面，执行全局代码就会形成，只有当页面关闭时候才会释放
     * 私有上下文：一般函数（代码块）中代码执行完，浏览器会自动把私有上下文出栈释放；但是如果，当前上下文中，某个和它关联的内容（一般指的是一个堆内存）被当前上下文以外的事物占用了，那么这个私有上下文不能出栈释放；这样私有上下文中的“私有变量/值”也被保存起来了！闭包的机制：保存、保护
     ************************************************************************/
    /**
     * 浏览器的垃圾回收机制：浏览器在空闲的时候，会把所有未被占用的内容释放掉，一次来优化内存空间
     * 对于前段开发来说，我们应该尽可能减少内存的开辟，并在把一些无用的内存取消对其的占用
     * **/ 
    //  let obj = { //0x000
    //   name: '胡歌',
    //   age: 18
    // }
    // obj --> 0x000

    // let obj2 = obj;
    // obj2 = null;
    // obj = 100;

    /**
     * 栈内存：执行上下文
     * 全局执行上下文，在浏览器打开页面的时候创建，在浏览器关掉页面的时候释放【F5刷新：把上一次的释放，再形成一个新的】
     * 私有上下文，默认情况下，代码执行完，都会出栈释放；但是如果，上下文中的某些内容（一般指在内部创建的函数）,被上下文以外的事物占用了，不仅被占用内容不能释放，连带着当前这个私有上下文也不能被释放。---> 闭包：函数执行，产生一个不被释放的上下文，这样不仅函数中的私有变量不受外界的干扰（保护），而且存储的信息也不会被释放掉（保存，可以供其下级上下文调取使用），我们把这种“保存+保护”的机制称为闭包。
     * **/ 
    
     let x = 5;
     function fn(x){
      return function(y){
        console.log(y+(++x));
      }
     }

     let f = fn(6);
     f(7);
     fn(8)(9);
     f(10);
     console.log(x);

     /**
      * 10+(++n) 先n累加1，累加后的再去和10运算
      * 10+(n++) 先拿n的值和10运算，运算完再把n++
      * ***/


  </script>
</body>
</html>